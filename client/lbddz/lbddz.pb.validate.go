// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: lbddz.proto

package lbddz

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Event with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Event) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Event with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in EventMultiError, or nil if none found.
func (m *Event) ValidateAll() error {
	return m.validate(true)
}

func (m *Event) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetMatchPlayer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EventValidationError{
					field:  "MatchPlayer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EventValidationError{
					field:  "MatchPlayer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMatchPlayer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EventValidationError{
				field:  "MatchPlayer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWantLandlord()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EventValidationError{
					field:  "WantLandlord",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EventValidationError{
					field:  "WantLandlord",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWantLandlord()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EventValidationError{
				field:  "WantLandlord",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPlayCardIn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EventValidationError{
					field:  "PlayCardIn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EventValidationError{
					field:  "PlayCardIn",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlayCardIn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EventValidationError{
				field:  "PlayCardIn",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EventMultiError(errors)
	}

	return nil
}

// EventMultiError is an error wrapping multiple validation errors returned by
// Event.ValidateAll() if the designated constraints aren't met.
type EventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EventMultiError) AllErrors() []error { return m }

// EventValidationError is the validation error returned by Event.Validate if
// the designated constraints aren't met.
type EventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventValidationError) ErrorName() string { return "EventValidationError" }

// Error satisfies the builtin error interface
func (e EventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventValidationError{}

// Validate checks the field values on Webhook with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Webhook) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Webhook with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in WebhookMultiError, or nil if none found.
func (m *Webhook) ValidateAll() error {
	return m.validate(true)
}

func (m *Webhook) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetException()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WebhookValidationError{
					field:  "Exception",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WebhookValidationError{
					field:  "Exception",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetException()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WebhookValidationError{
				field:  "Exception",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRegister()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WebhookValidationError{
					field:  "Register",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WebhookValidationError{
					field:  "Register",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRegister()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WebhookValidationError{
				field:  "Register",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLogin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WebhookValidationError{
					field:  "Login",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WebhookValidationError{
					field:  "Login",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLogin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WebhookValidationError{
				field:  "Login",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMatch()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WebhookValidationError{
					field:  "Match",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WebhookValidationError{
					field:  "Match",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMatch()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WebhookValidationError{
				field:  "Match",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGiveCard()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WebhookValidationError{
					field:  "GiveCard",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WebhookValidationError{
					field:  "GiveCard",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGiveCard()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WebhookValidationError{
				field:  "GiveCard",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStateChange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WebhookValidationError{
					field:  "StateChange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WebhookValidationError{
					field:  "StateChange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStateChange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WebhookValidationError{
				field:  "StateChange",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAckWantLandlord()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WebhookValidationError{
					field:  "AckWantLandlord",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WebhookValidationError{
					field:  "AckWantLandlord",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAckWantLandlord()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WebhookValidationError{
				field:  "AckWantLandlord",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWantLandlordOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WebhookValidationError{
					field:  "WantLandlordOutput",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WebhookValidationError{
					field:  "WantLandlordOutput",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWantLandlordOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WebhookValidationError{
				field:  "WantLandlordOutput",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWantLandlordResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WebhookValidationError{
					field:  "WantLandlordResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WebhookValidationError{
					field:  "WantLandlordResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWantLandlordResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WebhookValidationError{
				field:  "WantLandlordResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPlayCardOut()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WebhookValidationError{
					field:  "PlayCardOut",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WebhookValidationError{
					field:  "PlayCardOut",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlayCardOut()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WebhookValidationError{
				field:  "PlayCardOut",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WebhookMultiError(errors)
	}

	return nil
}

// WebhookMultiError is an error wrapping multiple validation errors returned
// by Webhook.ValidateAll() if the designated constraints aren't met.
type WebhookMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WebhookMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WebhookMultiError) AllErrors() []error { return m }

// WebhookValidationError is the validation error returned by Webhook.Validate
// if the designated constraints aren't met.
type WebhookValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WebhookValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WebhookValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WebhookValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WebhookValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WebhookValidationError) ErrorName() string { return "WebhookValidationError" }

// Error satisfies the builtin error interface
func (e WebhookValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWebhook.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WebhookValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WebhookValidationError{}

// Validate checks the field values on ModelPlayer with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ModelPlayer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelPlayer with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ModelPlayerMultiError, or
// nil if none found.
func (m *ModelPlayer) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelPlayer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for DeletedAt

	// no validation rules for Nickname

	// no validation rules for Username

	// no validation rules for Password

	// no validation rules for Avatar

	// no validation rules for LastLoginAt

	// no validation rules for IsOnline

	// no validation rules for CurIpAddr

	// no validation rules for LastIpAddr

	if len(errors) > 0 {
		return ModelPlayerMultiError(errors)
	}

	return nil
}

// ModelPlayerMultiError is an error wrapping multiple validation errors
// returned by ModelPlayer.ValidateAll() if the designated constraints aren't met.
type ModelPlayerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelPlayerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelPlayerMultiError) AllErrors() []error { return m }

// ModelPlayerValidationError is the validation error returned by
// ModelPlayer.Validate if the designated constraints aren't met.
type ModelPlayerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelPlayerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelPlayerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelPlayerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelPlayerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelPlayerValidationError) ErrorName() string { return "ModelPlayerValidationError" }

// Error satisfies the builtin error interface
func (e ModelPlayerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelPlayer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelPlayerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelPlayerValidationError{}

// Validate checks the field values on ModelRoom with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ModelRoom) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelRoom with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ModelRoomMultiError, or nil
// if none found.
func (m *ModelRoom) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelRoom) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for DeletedAt

	// no validation rules for CreatorId

	// no validation rules for Name

	if len(errors) > 0 {
		return ModelRoomMultiError(errors)
	}

	return nil
}

// ModelRoomMultiError is an error wrapping multiple validation errors returned
// by ModelRoom.ValidateAll() if the designated constraints aren't met.
type ModelRoomMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelRoomMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelRoomMultiError) AllErrors() []error { return m }

// ModelRoomValidationError is the validation error returned by
// ModelRoom.Validate if the designated constraints aren't met.
type ModelRoomValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelRoomValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelRoomValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelRoomValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelRoomValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelRoomValidationError) ErrorName() string { return "ModelRoomValidationError" }

// Error satisfies the builtin error interface
func (e ModelRoomValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelRoom.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelRoomValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelRoomValidationError{}

// Validate checks the field values on ModelGame with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ModelGame) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelGame with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ModelGameMultiError, or nil
// if none found.
func (m *ModelGame) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelGame) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for DeletedAt

	// no validation rules for RoomId

	// no validation rules for LandlordSeq

	// no validation rules for CurPlayerSeq

	// no validation rules for LastPlayerSeq

	// no validation rules for WantDiZhuTimes

	// no validation rules for CurLandlordScore

	if all {
		switch v := interface{}(m.GetLastCards()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelGameValidationError{
					field:  "LastCards",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelGameValidationError{
					field:  "LastCards",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastCards()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelGameValidationError{
				field:  "LastCards",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PassNum

	// no validation rules for NowBiggerSeq

	// no validation rules for State

	if len(errors) > 0 {
		return ModelGameMultiError(errors)
	}

	return nil
}

// ModelGameMultiError is an error wrapping multiple validation errors returned
// by ModelGame.ValidateAll() if the designated constraints aren't met.
type ModelGameMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelGameMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelGameMultiError) AllErrors() []error { return m }

// ModelGameValidationError is the validation error returned by
// ModelGame.Validate if the designated constraints aren't met.
type ModelGameValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelGameValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelGameValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelGameValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelGameValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelGameValidationError) ErrorName() string { return "ModelGameValidationError" }

// Error satisfies the builtin error interface
func (e ModelGameValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelGame.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelGameValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelGameValidationError{}

// Validate checks the field values on ModelGamePlayer with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ModelGamePlayer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelGamePlayer with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ModelGamePlayerMultiError, or nil if none found.
func (m *ModelGamePlayer) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelGamePlayer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for DeletedAt

	// no validation rules for RoomId

	// no validation rules for GameId

	// no validation rules for PlayerId

	// no validation rules for Seq

	// no validation rules for IsLandlord

	if len(errors) > 0 {
		return ModelGamePlayerMultiError(errors)
	}

	return nil
}

// ModelGamePlayerMultiError is an error wrapping multiple validation errors
// returned by ModelGamePlayer.ValidateAll() if the designated constraints
// aren't met.
type ModelGamePlayerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelGamePlayerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelGamePlayerMultiError) AllErrors() []error { return m }

// ModelGamePlayerValidationError is the validation error returned by
// ModelGamePlayer.Validate if the designated constraints aren't met.
type ModelGamePlayerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelGamePlayerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelGamePlayerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelGamePlayerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelGamePlayerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelGamePlayerValidationError) ErrorName() string { return "ModelGamePlayerValidationError" }

// Error satisfies the builtin error interface
func (e ModelGamePlayerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelGamePlayer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelGamePlayerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelGamePlayerValidationError{}

// Validate checks the field values on BaseGame with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BaseGame) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BaseGame with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BaseGameMultiError, or nil
// if none found.
func (m *BaseGame) ValidateAll() error {
	return m.validate(true)
}

func (m *BaseGame) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetG()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BaseGameValidationError{
					field:  "G",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BaseGameValidationError{
					field:  "G",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetG()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BaseGameValidationError{
				field:  "G",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetGps() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BaseGameValidationError{
						field:  fmt.Sprintf("Gps[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BaseGameValidationError{
						field:  fmt.Sprintf("Gps[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BaseGameValidationError{
					field:  fmt.Sprintf("Gps[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BaseGameMultiError(errors)
	}

	return nil
}

// BaseGameMultiError is an error wrapping multiple validation errors returned
// by BaseGame.ValidateAll() if the designated constraints aren't met.
type BaseGameMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BaseGameMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BaseGameMultiError) AllErrors() []error { return m }

// BaseGameValidationError is the validation error returned by
// BaseGame.Validate if the designated constraints aren't met.
type BaseGameValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BaseGameValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BaseGameValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BaseGameValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BaseGameValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BaseGameValidationError) ErrorName() string { return "BaseGameValidationError" }

// Error satisfies the builtin error interface
func (e BaseGameValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBaseGame.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BaseGameValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BaseGameValidationError{}

// Validate checks the field values on Register with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Register) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Register with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RegisterMultiError, or nil
// if none found.
func (m *Register) ValidateAll() error {
	return m.validate(true)
}

func (m *Register) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Username

	// no validation rules for Password

	if len(errors) > 0 {
		return RegisterMultiError(errors)
	}

	return nil
}

// RegisterMultiError is an error wrapping multiple validation errors returned
// by Register.ValidateAll() if the designated constraints aren't met.
type RegisterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterMultiError) AllErrors() []error { return m }

// RegisterValidationError is the validation error returned by
// Register.Validate if the designated constraints aren't met.
type RegisterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterValidationError) ErrorName() string { return "RegisterValidationError" }

// Error satisfies the builtin error interface
func (e RegisterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegister.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterValidationError{}

// Validate checks the field values on Login with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Login) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Login with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in LoginMultiError, or nil if none found.
func (m *Login) ValidateAll() error {
	return m.validate(true)
}

func (m *Login) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Username

	// no validation rules for Password

	if len(errors) > 0 {
		return LoginMultiError(errors)
	}

	return nil
}

// LoginMultiError is an error wrapping multiple validation errors returned by
// Login.ValidateAll() if the designated constraints aren't met.
type LoginMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginMultiError) AllErrors() []error { return m }

// LoginValidationError is the validation error returned by Login.Validate if
// the designated constraints aren't met.
type LoginValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginValidationError) ErrorName() string { return "LoginValidationError" }

// Error satisfies the builtin error interface
func (e LoginValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogin.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginValidationError{}

// Validate checks the field values on MatchPlayer with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MatchPlayer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MatchPlayer with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MatchPlayerMultiError, or
// nil if none found.
func (m *MatchPlayer) ValidateAll() error {
	return m.validate(true)
}

func (m *MatchPlayer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PlayerId

	if len(errors) > 0 {
		return MatchPlayerMultiError(errors)
	}

	return nil
}

// MatchPlayerMultiError is an error wrapping multiple validation errors
// returned by MatchPlayer.ValidateAll() if the designated constraints aren't met.
type MatchPlayerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MatchPlayerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MatchPlayerMultiError) AllErrors() []error { return m }

// MatchPlayerValidationError is the validation error returned by
// MatchPlayer.Validate if the designated constraints aren't met.
type MatchPlayerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MatchPlayerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MatchPlayerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MatchPlayerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MatchPlayerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MatchPlayerValidationError) ErrorName() string { return "MatchPlayerValidationError" }

// Error satisfies the builtin error interface
func (e MatchPlayerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMatchPlayer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MatchPlayerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MatchPlayerValidationError{}

// Validate checks the field values on RegisterResult with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RegisterResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterResult with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RegisterResultMultiError,
// or nil if none found.
func (m *RegisterResult) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPlayer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegisterResultValidationError{
					field:  "Player",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegisterResultValidationError{
					field:  "Player",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlayer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegisterResultValidationError{
				field:  "Player",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RegisterResultMultiError(errors)
	}

	return nil
}

// RegisterResultMultiError is an error wrapping multiple validation errors
// returned by RegisterResult.ValidateAll() if the designated constraints
// aren't met.
type RegisterResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterResultMultiError) AllErrors() []error { return m }

// RegisterResultValidationError is the validation error returned by
// RegisterResult.Validate if the designated constraints aren't met.
type RegisterResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterResultValidationError) ErrorName() string { return "RegisterResultValidationError" }

// Error satisfies the builtin error interface
func (e RegisterResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterResultValidationError{}

// Validate checks the field values on LoginResult with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginResult with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginResultMultiError, or
// nil if none found.
func (m *LoginResult) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPlayer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LoginResultValidationError{
					field:  "Player",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LoginResultValidationError{
					field:  "Player",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPlayer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LoginResultValidationError{
				field:  "Player",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LoginResultMultiError(errors)
	}

	return nil
}

// LoginResultMultiError is an error wrapping multiple validation errors
// returned by LoginResult.ValidateAll() if the designated constraints aren't met.
type LoginResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginResultMultiError) AllErrors() []error { return m }

// LoginResultValidationError is the validation error returned by
// LoginResult.Validate if the designated constraints aren't met.
type LoginResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginResultValidationError) ErrorName() string { return "LoginResultValidationError" }

// Error satisfies the builtin error interface
func (e LoginResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginResultValidationError{}

// Validate checks the field values on MatchResult with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MatchResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MatchResult with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MatchResultMultiError, or
// nil if none found.
func (m *MatchResult) ValidateAll() error {
	return m.validate(true)
}

func (m *MatchResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPlayers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MatchResultValidationError{
						field:  fmt.Sprintf("Players[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MatchResultValidationError{
						field:  fmt.Sprintf("Players[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MatchResultValidationError{
					field:  fmt.Sprintf("Players[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetRoom()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MatchResultValidationError{
					field:  "Room",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MatchResultValidationError{
					field:  "Room",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRoom()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MatchResultValidationError{
				field:  "Room",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MatchResultMultiError(errors)
	}

	return nil
}

// MatchResultMultiError is an error wrapping multiple validation errors
// returned by MatchResult.ValidateAll() if the designated constraints aren't met.
type MatchResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MatchResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MatchResultMultiError) AllErrors() []error { return m }

// MatchResultValidationError is the validation error returned by
// MatchResult.Validate if the designated constraints aren't met.
type MatchResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MatchResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MatchResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MatchResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MatchResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MatchResultValidationError) ErrorName() string { return "MatchResultValidationError" }

// Error satisfies the builtin error interface
func (e MatchResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMatchResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MatchResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MatchResultValidationError{}

// Validate checks the field values on GiveCard with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GiveCard) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GiveCard with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GiveCardMultiError, or nil
// if none found.
func (m *GiveCard) ValidateAll() error {
	return m.validate(true)
}

func (m *GiveCard) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBaseGame()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GiveCardValidationError{
					field:  "BaseGame",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GiveCardValidationError{
					field:  "BaseGame",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBaseGame()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GiveCardValidationError{
				field:  "BaseGame",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GiveCardMultiError(errors)
	}

	return nil
}

// GiveCardMultiError is an error wrapping multiple validation errors returned
// by GiveCard.ValidateAll() if the designated constraints aren't met.
type GiveCardMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GiveCardMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GiveCardMultiError) AllErrors() []error { return m }

// GiveCardValidationError is the validation error returned by
// GiveCard.Validate if the designated constraints aren't met.
type GiveCardValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GiveCardValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GiveCardValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GiveCardValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GiveCardValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GiveCardValidationError) ErrorName() string { return "GiveCardValidationError" }

// Error satisfies the builtin error interface
func (e GiveCardValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGiveCard.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GiveCardValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GiveCardValidationError{}

// Validate checks the field values on StateChange with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StateChange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StateChange with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StateChangeMultiError, or
// nil if none found.
func (m *StateChange) ValidateAll() error {
	return m.validate(true)
}

func (m *StateChange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StateChange

	if len(errors) > 0 {
		return StateChangeMultiError(errors)
	}

	return nil
}

// StateChangeMultiError is an error wrapping multiple validation errors
// returned by StateChange.ValidateAll() if the designated constraints aren't met.
type StateChangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StateChangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StateChangeMultiError) AllErrors() []error { return m }

// StateChangeValidationError is the validation error returned by
// StateChange.Validate if the designated constraints aren't met.
type StateChangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StateChangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StateChangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StateChangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StateChangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StateChangeValidationError) ErrorName() string { return "StateChangeValidationError" }

// Error satisfies the builtin error interface
func (e StateChangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStateChange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StateChangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StateChangeValidationError{}

// Validate checks the field values on Exception with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Exception) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Exception with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExceptionMultiError, or nil
// if none found.
func (m *Exception) ValidateAll() error {
	return m.validate(true)
}

func (m *Exception) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Message

	if len(errors) > 0 {
		return ExceptionMultiError(errors)
	}

	return nil
}

// ExceptionMultiError is an error wrapping multiple validation errors returned
// by Exception.ValidateAll() if the designated constraints aren't met.
type ExceptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExceptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExceptionMultiError) AllErrors() []error { return m }

// ExceptionValidationError is the validation error returned by
// Exception.Validate if the designated constraints aren't met.
type ExceptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExceptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExceptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExceptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExceptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExceptionValidationError) ErrorName() string { return "ExceptionValidationError" }

// Error satisfies the builtin error interface
func (e ExceptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sException.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExceptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExceptionValidationError{}

// Validate checks the field values on WantLandlord with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WantLandlord) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WantLandlord with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WantLandlordMultiError, or
// nil if none found.
func (m *WantLandlord) ValidateAll() error {
	return m.validate(true)
}

func (m *WantLandlord) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GameId

	// no validation rules for Score

	if len(errors) > 0 {
		return WantLandlordMultiError(errors)
	}

	return nil
}

// WantLandlordMultiError is an error wrapping multiple validation errors
// returned by WantLandlord.ValidateAll() if the designated constraints aren't met.
type WantLandlordMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WantLandlordMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WantLandlordMultiError) AllErrors() []error { return m }

// WantLandlordValidationError is the validation error returned by
// WantLandlord.Validate if the designated constraints aren't met.
type WantLandlordValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WantLandlordValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WantLandlordValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WantLandlordValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WantLandlordValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WantLandlordValidationError) ErrorName() string { return "WantLandlordValidationError" }

// Error satisfies the builtin error interface
func (e WantLandlordValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWantLandlord.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WantLandlordValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WantLandlordValidationError{}

// Validate checks the field values on WantLandlordOutput with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WantLandlordOutput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WantLandlordOutput with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WantLandlordOutputMultiError, or nil if none found.
func (m *WantLandlordOutput) ValidateAll() error {
	return m.validate(true)
}

func (m *WantLandlordOutput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StateChange

	// no validation rules for CurPlayerSeq

	// no validation rules for NewScore

	if len(errors) > 0 {
		return WantLandlordOutputMultiError(errors)
	}

	return nil
}

// WantLandlordOutputMultiError is an error wrapping multiple validation errors
// returned by WantLandlordOutput.ValidateAll() if the designated constraints
// aren't met.
type WantLandlordOutputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WantLandlordOutputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WantLandlordOutputMultiError) AllErrors() []error { return m }

// WantLandlordOutputValidationError is the validation error returned by
// WantLandlordOutput.Validate if the designated constraints aren't met.
type WantLandlordOutputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WantLandlordOutputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WantLandlordOutputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WantLandlordOutputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WantLandlordOutputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WantLandlordOutputValidationError) ErrorName() string {
	return "WantLandlordOutputValidationError"
}

// Error satisfies the builtin error interface
func (e WantLandlordOutputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWantLandlordOutput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WantLandlordOutputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WantLandlordOutputValidationError{}

// Validate checks the field values on WantLandlordResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WantLandlordResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WantLandlordResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WantLandlordResultMultiError, or nil if none found.
func (m *WantLandlordResult) ValidateAll() error {
	return m.validate(true)
}

func (m *WantLandlordResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StateChange

	// no validation rules for CurPlayerSeq

	// no validation rules for NewScore

	if len(errors) > 0 {
		return WantLandlordResultMultiError(errors)
	}

	return nil
}

// WantLandlordResultMultiError is an error wrapping multiple validation errors
// returned by WantLandlordResult.ValidateAll() if the designated constraints
// aren't met.
type WantLandlordResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WantLandlordResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WantLandlordResultMultiError) AllErrors() []error { return m }

// WantLandlordResultValidationError is the validation error returned by
// WantLandlordResult.Validate if the designated constraints aren't met.
type WantLandlordResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WantLandlordResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WantLandlordResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WantLandlordResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WantLandlordResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WantLandlordResultValidationError) ErrorName() string {
	return "WantLandlordResultValidationError"
}

// Error satisfies the builtin error interface
func (e WantLandlordResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWantLandlordResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WantLandlordResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WantLandlordResultValidationError{}

// Validate checks the field values on Ack with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Ack) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Ack with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AckMultiError, or nil if none found.
func (m *Ack) ValidateAll() error {
	return m.validate(true)
}

func (m *Ack) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Seq

	if len(errors) > 0 {
		return AckMultiError(errors)
	}

	return nil
}

// AckMultiError is an error wrapping multiple validation errors returned by
// Ack.ValidateAll() if the designated constraints aren't met.
type AckMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AckMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AckMultiError) AllErrors() []error { return m }

// AckValidationError is the validation error returned by Ack.Validate if the
// designated constraints aren't met.
type AckValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AckValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AckValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AckValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AckValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AckValidationError) ErrorName() string { return "AckValidationError" }

// Error satisfies the builtin error interface
func (e AckValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAck.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AckValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AckValidationError{}

// Validate checks the field values on CardSet with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CardSet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CardSet with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CardSetMultiError, or nil if none found.
func (m *CardSet) ValidateAll() error {
	return m.validate(true)
}

func (m *CardSet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CardType

	// no validation rules for Header

	if len(errors) > 0 {
		return CardSetMultiError(errors)
	}

	return nil
}

// CardSetMultiError is an error wrapping multiple validation errors returned
// by CardSet.ValidateAll() if the designated constraints aren't met.
type CardSetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CardSetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CardSetMultiError) AllErrors() []error { return m }

// CardSetValidationError is the validation error returned by CardSet.Validate
// if the designated constraints aren't met.
type CardSetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CardSetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CardSetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CardSetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CardSetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CardSetValidationError) ErrorName() string { return "CardSetValidationError" }

// Error satisfies the builtin error interface
func (e CardSetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCardSet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CardSetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CardSetValidationError{}

// Validate checks the field values on PlayCardIn with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PlayCardIn) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlayCardIn with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PlayCardInMultiError, or
// nil if none found.
func (m *PlayCardIn) ValidateAll() error {
	return m.validate(true)
}

func (m *PlayCardIn) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GameId

	if all {
		switch v := interface{}(m.GetCurCard()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PlayCardInValidationError{
					field:  "CurCard",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PlayCardInValidationError{
					field:  "CurCard",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurCard()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PlayCardInValidationError{
				field:  "CurCard",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PlayCardInMultiError(errors)
	}

	return nil
}

// PlayCardInMultiError is an error wrapping multiple validation errors
// returned by PlayCardIn.ValidateAll() if the designated constraints aren't met.
type PlayCardInMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlayCardInMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlayCardInMultiError) AllErrors() []error { return m }

// PlayCardInValidationError is the validation error returned by
// PlayCardIn.Validate if the designated constraints aren't met.
type PlayCardInValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlayCardInValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlayCardInValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlayCardInValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlayCardInValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlayCardInValidationError) ErrorName() string { return "PlayCardInValidationError" }

// Error satisfies the builtin error interface
func (e PlayCardInValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlayCardIn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlayCardInValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlayCardInValidationError{}

// Validate checks the field values on PlayCardOut with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PlayCardOut) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PlayCardOut with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PlayCardOutMultiError, or
// nil if none found.
func (m *PlayCardOut) ValidateAll() error {
	return m.validate(true)
}

func (m *PlayCardOut) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StateChange

	// no validation rules for NextSeq

	if all {
		switch v := interface{}(m.GetCurCard()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PlayCardOutValidationError{
					field:  "CurCard",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PlayCardOutValidationError{
					field:  "CurCard",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCurCard()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PlayCardOutValidationError{
				field:  "CurCard",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PlayCardOutMultiError(errors)
	}

	return nil
}

// PlayCardOutMultiError is an error wrapping multiple validation errors
// returned by PlayCardOut.ValidateAll() if the designated constraints aren't met.
type PlayCardOutMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PlayCardOutMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PlayCardOutMultiError) AllErrors() []error { return m }

// PlayCardOutValidationError is the validation error returned by
// PlayCardOut.Validate if the designated constraints aren't met.
type PlayCardOutValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PlayCardOutValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PlayCardOutValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PlayCardOutValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PlayCardOutValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PlayCardOutValidationError) ErrorName() string { return "PlayCardOutValidationError" }

// Error satisfies the builtin error interface
func (e PlayCardOutValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlayCardOut.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PlayCardOutValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PlayCardOutValidationError{}
